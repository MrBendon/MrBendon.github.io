<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><meta name="author" content="Mr.Bendon"><link rel="icon" href="/hexo.png"><title>Mr.Bendon 菜雞啄食場</title><meta name="description" content="MyHexo"><link rel="alternate" type="application/rss+xml" title="Mr.Bendon 菜雞啄食場" href="/atom.xml"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/highlight.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"><meta name="generator" content="Hexo 7.0.0"></head><body><nav class="navbar navbar-default navbar-fixed-top navbar-custom"><div class="container-fluid"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#main-navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Mr.Bendon 菜雞啄食場</a></div><div id="main-navbar" class="collapse navbar-collapse"><ul class="nav navbar-nav navbar-right"><li><a href="/archives">Archive</a></li><li><a target="_blank" rel="noopener" href="https://github.com/twoyao/beautiful-hexo">Github</a></li><li><a href="/about/">About</a></li></ul></div><div class="avatar-container"><div class="avatar-img-border"><a href="/"><img src="/hexo.png" class="avatar-img"></a></div></div></div></nav><header class="header-section"><div class="intro-header no-img"><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"><h1>什麼情況等號兩邊會相等（===）?</h1><p class="post-meta">Posted on Jan 9 2024 · <a href="/tags/Object-is-Primitive-Type-Object-Type/" class="tag post-meta">Object.is()  Primitive Type  Object Type</a></p></div></div></div></div></div></header><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><article role="main" class="blog-post"><p>什麼時候 &#x3D;&#x3D;&#x3D; 兩邊會一樣？這個是運算符號主要是用來比較兩個值是否相等以及它們的型別是否相同，今天先說說比較值的部分。</p>
<p>首先，資料型態的部分，在最新的 ECMAScript 標準定義了 8 種資料類型，其中可以分為兩大類，一大類是原始資料( Primitive types )類型，代表但一個值，包含以下七種：</p>
<span id="more"></span>

<ol>
<li>Boolean(true and false)</li>
<li>null(特殊關鍵字，JS 對於大小寫是有分辨性的，所以這裡一定是 null，而不是 Null、NULL)</li>
<li>undefined（特殊關鍵字，表示變數未賦值時的屬性）</li>
<li>Number(整數或浮點數)</li>
<li>BigInt(安全地儲存和操作大整數，甚至可以超過數字的安全整數限制)</li>
<li>String</li>
<li>Symbol</li>
</ol>
<p>第二大類則是物件(Object)，是資料的集合體，包含 function、array、object。</p>
<p>其實人類看起來像是變數保存了一個數值，但實際上，變數更像是一個書名，或一個標示符號，只是告訴了人類說，「嘿，這里面的資料外面叫這個名字」。</p>
<p>在原始資料中，資料的儲存方式為變數直接在名為 Stack 的記憶體空間佔用一個位置（例如叫做 0x001)並且直接將值放入其中。概念如下圖：</p>
<p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124161769_Primitive+Data.png"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p>
<p>Stack 是相對小但存取相對快的記憶體空間，變數會以變數表的概念儲存於其中，表中包含：「變數名稱」、「記憶體位置」、「資料的值」。</p>
<p>而物件型別則是同樣會在 Stack 佔用一個位置，但放入的資料卻像是一個超連結或這是一個位置資訊（Address），實際上 Object 的資料會存放在名為 Heap 的儲存空間，而剛剛提到的位置資訊，則是 Object 放在 Heap 的位置資訊。概念如下圖：</p>
<p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124177518_Oblect+Data.png"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p>
<p>Heap 相對於 Stack 是較大的記憶體空間，更適合儲存 Object data 這種較大的資料，當然相對存取會比較慢。</p>
<p>所以呢？複製資料與後續資料變更的這些行為也會因為資料型態的不同而會產生出不同的結果。</p>
<p>在複製原始型態的資料時，則是新的變數會複製舊的值（value），並且在 Stack 佔用新的一個記憶體位置，再將數值放入到記憶體中。概念如下圖：</p>
<p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124186975_Primitive+Data.png"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p>
<p>而物件型態的則因為其值是放在 Heap，所以複製 Object 時則行為則不一樣。同樣的新的變數在複製的時候一樣是會複製舊變數中的值，並且在 Stack 記憶體中佔用一個位置，但由於是物件型式，所以複製到的資料其實是一個 Heap 的資料位置，概念如下圖：</p>
<p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124193901_Oblect+Data+.png"></p>
<p>（圖片來源：<a target="_blank" rel="noopener" href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p>
<p>所以總結一下，兩種類型的複製行為：<br>在大多數的情況下，原始型態的資料會是傳值（Pass by value)，而物件型態則是會透過傳址（Pass by reference)的方式來運作，這個概念在後續資料的處理和資料的比對上很重要。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;;    <span class="comment">// 創造了一個物件，指向某一個Heap，例如指向記憶體大樓一樓）</span></span><br><span class="line"><span class="keyword">const</span> b = a;   <span class="comment">//  由於是複製物件是pass by reference，因此這裡只是在Stack創造了一個b，但內容複製了a所記錄的地址，也就是他也指向記憶體大樓一樓）</span></span><br><span class="line">a.<span class="property">value</span> = <span class="number">100</span>  <span class="comment">// 修改了記憶體大樓一樓中的資料</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a===b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>此時 b.value 也會變為 100，而且此時 console.log(a&#x3D;&#x3D;&#x3D;b)為 true。</p>
<p>但若情況為:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;  <span class="comment">//創造了一個物件，指向某一個Heap，例如指向記憶體大樓一樓）</span></span><br><span class="line"><span class="keyword">const</span> d = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;  <span class="comment">//再創造了一個物件，指向另一個Heap，例如指向記憶體大樓二樓）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c === d)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>這裡雖然是兩個不同的概念，但基本上是要先理解<br>「物件型態的資料是存放在 Heap（堆）並且 stack 是紀錄 Heap 的位置 」的這個概念。</p>
<p>此外這個結果也告訴我們，ＪＳ中的兩個物件比對的其中一種方式就是這種「引用比較」（Reference Comparison)，比較的是兩個物件在 Stack 中是否指向相同的記憶體位置（比較地址的）。而一般我們常用的” &#x3D;&#x3D;&#x3D; ” 和 Object.is 都是屬於「引用比較」。</p>
<p>另外，在 js 中拷貝物件也有分為淺拷貝和深拷貝，其概念也是上述概念的延伸。<br>淺拷貝只是複製了引用（地址），而不是實際的內容（Heap 中的內容），代表新物件和舊物件仍然指向同一個 Heap。<br>物件常見的淺拷貝方式：<br>Object.assign()<br>使用 <code>…</code>展開運算子展開物件<br>而陣列常見的淺拷貝方式：<br>利用一些會回傳新陣列的方法：例如 slice、map、concat、filter 等等</p>
<p>深拷貝則是實實在在的創建了一個新的物件，有點類似像上述的 cd 例子一樣，其指向的 Heap 並不相同。</p>
<p>但有一個狀況是比較特別的，就是如果是一個物件被當作函數參數來進行傳遞，且該物件在函數中被重新賦值時，則該物件讚外部的內容是不會被改變的。這種模式叫做 pass by sharing，其範例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reassignObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj = &#123; <span class="attr">newKey</span>: <span class="string">&#x27;new object&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// obj被重新賦值了（重新賦值是指將一個變數指向一個全新的物件，而不是修改原始物件的內容。）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalObj = &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">reassignObject</span>(originalObj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObj.<span class="property">key</span>);  <span class="comment">// &#x27;value&#x27;，原始物件未受影響</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObj.<span class="property">newKey</span>);  <span class="comment">// undefined，重新賦值不影響原始物件</span></span><br></pre></td></tr></table></figure>

<p>但如果只是修改屬性值，則會回到剛剛上述所提到的 pass by reference 模式，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modifyObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj.<span class="property">key</span> = <span class="string">&#x27;new value&#x27;</span>;  <span class="comment">//. 只是修改屬性值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalObj = &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">modifyObject</span>(originalObj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObj.<span class="property">key</span>); <span class="comment">// &#x27;new value&#x27;，原始物件被修改</span></span><br></pre></td></tr></table></figure>

<p>因為他們有者相同的引用（地址），所以都會被修改到。</p>
<p>型態就留到明天了。</p>
</article><ul class="pager blog-pager"><li class="next"><a href="/2024/01/04/useCllback/" data-toggle="tooltip" data-placement="top" title="什麼是 useCllback ？">Next Post →</a></li></ul><div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div><script src="//img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"> </script><script>var cloudTieConfig = {
  url: document.location.href, 
  sourceId: "",
  productKey: "64d7f0abf9224be3bfdcc6cfb9b83fcf",
  target: "cloud-tie-wrapper"
};</script></div></div></div><footer><div class="container beautiful-jekyll-footer"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center footer-links"><li><a target="_blank" rel="noopener" href="http://weibo.com/bisyao?is_all=1" title="Weibo"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-weibo"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://github.com/twoyao" title="GitHub"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-github"></i></span></a></li><li><a href="/atom.xml" title="RSS"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-rss"></i></span></a></li><li><a target="_blank" rel="noopener" href="https://twitter.com/twoyao_" title="Twitter"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-twitter"></i></span></a></li><li><a href="mailto:bisyao@gmail.com" title="Email me"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-stack-1x fa-inverse fa-envelope"></i></span></a></li></ul><p class="copyright text-muted">© Mr.Bendon • 2024 • <a href="mailto:undefined"></a>
</p><p class="theme-by text-muted">Theme by
<a target="_blank" rel="noopener" href="https://github.com/twoyao/beautiful-hexo">beautiful-hexo</a></p></div></div></div></footer><script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script><script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>