<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr.Bendon 菜雞啄食場</title>
  
  <subtitle>在學習的漫長路上，緩緩前進</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-08T16:35:45.590Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mr.Bendon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>什麼情況等號兩邊會相等（===）?</title>
    <link href="http://example.com/2024/01/09/equal/"/>
    <id>http://example.com/2024/01/09/equal/</id>
    <published>2024-01-08T16:10:02.000Z</published>
    <updated>2024-01-08T16:35:45.590Z</updated>
    
    <content type="html"><![CDATA[<p>什麼時候 &#x3D;&#x3D;&#x3D; 兩邊會一樣？這個是運算符號主要是用來比較兩個值是否相等以及它們的型別是否相同，今天先說說比較值的部分。</p><p>首先，資料型態的部分，在最新的 ECMAScript 標準定義了 8 種資料類型，其中可以分為兩大類，一大類是原始資料( Primitive types )類型，代表但一個值，包含以下七種：</p><span id="more"></span><ol><li>Boolean(true and false)</li><li>null(特殊關鍵字，JS 對於大小寫是有分辨性的，所以這裡一定是 null，而不是 Null、NULL)</li><li>undefined（特殊關鍵字，表示變數未賦值時的屬性）</li><li>Number(整數或浮點數)</li><li>BigInt(安全地儲存和操作大整數，甚至可以超過數字的安全整數限制)</li><li>String</li><li>Symbol</li></ol><p>第二大類則是物件(Object)，是資料的集合體，包含 function、array、object。</p><p>其實人類看起來像是變數保存了一個數值，但實際上，變數更像是一個書名，或一個標示符號，只是告訴了人類說，「嘿，這里面的資料外面叫這個名字」。</p><p>在原始資料中，資料的儲存方式為變數直接在名為 Stack 的記憶體空間佔用一個位置（例如叫做 0x001)並且直接將值放入其中。概念如下圖：</p><p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124161769_Primitive+Data.png"></p><p>（圖片來源：<a href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p><p>Stack 是相對小但存取相對快的記憶體空間，變數會以變數表的概念儲存於其中，表中包含：「變數名稱」、「記憶體位置」、「資料的值」。</p><p>而物件型別則是同樣會在 Stack 佔用一個位置，但放入的資料卻像是一個超連結或這是一個位置資訊（Address），實際上 Object 的資料會存放在名為 Heap 的儲存空間，而剛剛提到的位置資訊，則是 Object 放在 Heap 的位置資訊。概念如下圖：</p><p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124177518_Oblect+Data.png"></p><p>（圖片來源：<a href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p><p>Heap 相對於 Stack 是較大的記憶體空間，更適合儲存 Object data 這種較大的資料，當然相對存取會比較慢。</p><p>所以呢？複製資料與後續資料變更的這些行為也會因為資料型態的不同而會產生出不同的結果。</p><p>在複製原始型態的資料時，則是新的變數會複製舊的值（value），並且在 Stack 佔用新的一個記憶體位置，再將數值放入到記憶體中。概念如下圖：</p><p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124186975_Primitive+Data.png"></p><p>（圖片來源：<a href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p><p>而物件型態的則因為其值是放在 Heap，所以複製 Object 時則行為則不一樣。同樣的新的變數在複製的時候一樣是會複製舊變數中的值，並且在 Stack 記憶體中佔用一個位置，但由於是物件型式，所以複製到的資料其實是一個 Heap 的資料位置，概念如下圖：</p><p><img src="https://paper-attachments.dropboxusercontent.com/s_69319D79F89D45490AC5840DF08FECF62D9AC8F6ED002EA7C62FE481D6B18D94_1704124193901_Oblect+Data+.png"></p><p>（圖片來源：<a href="https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing%EF%BC%89">https://www.programfarmer.com/articles/2021/javascript-pass-by-value-pass-by-reference-pass-by-sharing）</a></p><p>所以總結一下，兩種類型的複製行為：<br>在大多數的情況下，原始型態的資料會是傳值（Pass by value)，而物件型態則是會透過傳址（Pass by reference)的方式來運作，這個概念在後續資料的處理和資料的比對上很重要。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;;    <span class="comment">// 創造了一個物件，指向某一個Heap，例如指向記憶體大樓一樓）</span></span><br><span class="line"><span class="keyword">const</span> b = a;   <span class="comment">//  由於是複製物件是pass by reference，因此這裡只是在Stack創造了一個b，但內容複製了a所記錄的地址，也就是他也指向記憶體大樓一樓）</span></span><br><span class="line">a.<span class="property">value</span> = <span class="number">100</span>  <span class="comment">// 修改了記憶體大樓一樓中的資料</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a===b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>此時 b.value 也會變為 100，而且此時 console.log(a&#x3D;&#x3D;&#x3D;b)為 true。</p><p>但若情況為:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;  <span class="comment">//創造了一個物件，指向某一個Heap，例如指向記憶體大樓一樓）</span></span><br><span class="line"><span class="keyword">const</span> d = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;;  <span class="comment">//再創造了一個物件，指向另一個Heap，例如指向記憶體大樓二樓）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c === d)  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>這裡雖然是兩個不同的概念，但基本上是要先理解<br>「物件型態的資料是存放在 Heap（堆）並且 stack 是紀錄 Heap 的位置 」的這個概念。</p><p>此外這個結果也告訴我們，ＪＳ中的兩個物件比對的其中一種方式就是這種「引用比較」（Reference Comparison)，比較的是兩個物件在 Stack 中是否指向相同的記憶體位置（比較地址的）。而一般我們常用的” &#x3D;&#x3D;&#x3D; ” 和 Object.is 都是屬於「引用比較」。</p><p>另外，在 js 中拷貝物件也有分為淺拷貝和深拷貝，其概念也是上述概念的延伸。<br>淺拷貝只是複製了引用（地址），而不是實際的內容（Heap 中的內容），代表新物件和舊物件仍然指向同一個 Heap。<br>物件常見的淺拷貝方式：<br>Object.assign()<br>使用 <code>…</code>展開運算子展開物件<br>而陣列常見的淺拷貝方式：<br>利用一些會回傳新陣列的方法：例如 slice、map、concat、filter 等等</p><p>深拷貝則是實實在在的創建了一個新的物件，有點類似像上述的 cd 例子一樣，其指向的 Heap 並不相同。</p><p>但有一個狀況是比較特別的，就是如果是一個物件被當作函數參數來進行傳遞，且該物件在函數中被重新賦值時，則該物件讚外部的內容是不會被改變的。這種模式叫做 pass by sharing，其範例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reassignObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj = &#123; <span class="attr">newKey</span>: <span class="string">&#x27;new object&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// obj被重新賦值了（重新賦值是指將一個變數指向一個全新的物件，而不是修改原始物件的內容。）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalObj = &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">reassignObject</span>(originalObj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObj.<span class="property">key</span>);  <span class="comment">// &#x27;value&#x27;，原始物件未受影響</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObj.<span class="property">newKey</span>);  <span class="comment">// undefined，重新賦值不影響原始物件</span></span><br></pre></td></tr></table></figure><p>但如果只是修改屬性值，則會回到剛剛上述所提到的 pass by reference 模式，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">modifyObject</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj.<span class="property">key</span> = <span class="string">&#x27;new value&#x27;</span>;  <span class="comment">//. 只是修改屬性值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> originalObj = &#123; <span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">modifyObject</span>(originalObj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(originalObj.<span class="property">key</span>); <span class="comment">// &#x27;new value&#x27;，原始物件被修改</span></span><br></pre></td></tr></table></figure><p>因為他們有者相同的引用（地址），所以都會被修改到。</p><p>型態就留到明天了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什麼時候 &amp;#x3D;&amp;#x3D;&amp;#x3D; 兩邊會一樣？這個是運算符號主要是用來比較兩個值是否相等以及它們的型別是否相同，今天先說說比較值的部分。&lt;/p&gt;
&lt;p&gt;首先，資料型態的部分，在最新的 ECMAScript 標準定義了 8 種資料類型，其中可以分為兩大類，一大類是原始資料( Primitive types )類型，代表但一個值，包含以下七種：&lt;/p&gt;</summary>
    
    
    
    
    <category term="Object.is()  Primitive Type  Object Type" scheme="http://example.com/tags/Object-is-Primitive-Type-Object-Type/"/>
    
  </entry>
  
  <entry>
    <title>什麼是 useCllback ？</title>
    <link href="http://example.com/2024/01/04/useCllback/"/>
    <id>http://example.com/2024/01/04/useCllback/</id>
    <published>2024-01-03T16:06:51.000Z</published>
    <updated>2024-01-08T16:37:17.973Z</updated>
    
    <content type="html"><![CDATA[<p>在 react 的渲染機制中，只要 React 元件內的資料狀態(state)有變動時，整個用來產生 React 元件的 Function 都會再重新執行一次．又或者，當父元件有資料狀態改變時，子元件也是會跟著重新渲染（re-render)。</p><p>但如果今天有一個情形是，子元件接受數個父元件傳來 props，但傳過來的這些 props 並沒有發生改變，改變的可能只是父元件中其他的狀態（就是傳給子元件的那幾個沒有被變動到），但即便如此，由於父元件需要重新渲染，因此即便傳過來的狀態一樣，但子元件仍然需要一起重新渲染．</p><span id="more"></span><p>這可能會發生什麼問題，假如子元件中沒有什麼需要消耗性能的繁重計算，那可能重新渲染的影響不大．但如果是一個需要繁重計算或者需要大量性能的函式呢？像是子元件中如果有包含以下但不限於：</p><ul><li>大型數據的迴圈計算（特別是在每次迴圈中進行複雜的數據處理或計算，若有多重嵌套回圈則可能會會導致計算的指數級增長）</li><li>頻繁的添加移除修改ＤＯＭ元素（例如透過ＪＳ動態大量生成表單、表格與使用者互動時）</li><li>有很多或複雜的動畫效果</li><li>對大型圖像或很多圖像進行處理</li></ul><p>上述狀況都有可能會影響到渲染效能，因此如果父元件重新渲染了，但子元件其實狀態不需要再次改變的情況下，我們可以借助 useCallback 這個方式來避免這個成本高的計算但「不必要的重新渲染」．進而提升渲染效率。</p><p>useCallback 的運作方式和 useMemo 很像，函式的樣子和 useEffect 也很像。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cachedFn = <span class="title function_">useCallback</span>(fn, dependencies)</span><br></pre></td></tr></table></figure><p>以上是 useCallback 的使用方式，cachedFn 會記憶 useCallback 所包含著的函式計算結果，並且只有在 dependencies (array 的形式，像是一個檢查清單）內的項目有改變時，才會去重新執行 fn，換言之，若 dependencies 中的項目都沒有改變過，則 fn 不會重新計算（不會被觸發），而 cachedFn 會得到之前的計算結果，與舊值相同。</p><p>fn 為可以接受任何參數並且傳回任何值的函數，不一定要是產生元件的 function，也可以是元件中相對消耗效能的 function。這一個 fn 會在 react 初次渲染而非呼叫時傳回該函數時，會執行一次，當元件進行下一次渲染時，如果 dependencies 相較於上一次渲染時沒有改變，那麼 React 將會傳回相同的函數。</p><p>dependencies 的形式為一個 array，例如：[dep1, dep2, dep3]，如果陣列中的項目沒有改變，則 fn 不會執行．要注意的是，React 判斷「dep1 有沒有改變」是使用 Object.is 的方法來比對新的 dep1 和舊值 dep1。所以要注意一下 Object.is 比較的結果或特性。如果 dependencies 放入一個空的陣列，則代表每一次渲染都還是會重新計算（react 在檢查清單中</p><p>那麼說說 useCallback 和 useMemo 的異同。</p><p><strong>同樣的部分：</strong><br>他們都是為了要提升渲染效能有關的，它們的主要作用是緩存（memoize）一些值或函式，以避免在包住（記憶）的值或函示在每次渲染時都會重新計算或再創建．</p><p><strong>不一樣的部分</strong><br>useMemo 是用來記憶某一個函示計算的值（結果）．而 useCallback 則是用來記憶一個函式本身的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 react 的渲染機制中，只要 React 元件內的資料狀態(state)有變動時，整個用來產生 React 元件的 Function 都會再重新執行一次．又或者，當父元件有資料狀態改變時，子元件也是會跟著重新渲染（re-render)。&lt;/p&gt;
&lt;p&gt;但如果今天有一個情形是，子元件接受數個父元件傳來 props，但傳過來的這些 props 並沒有發生改變，改變的可能只是父元件中其他的狀態（就是傳給子元件的那幾個沒有被變動到），但即便如此，由於父元件需要重新渲染，因此即便傳過來的狀態一樣，但子元件仍然需要一起重新渲染．&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>什麼是 useEffect ?</title>
    <link href="http://example.com/2023/12/31/useEffect/"/>
    <id>http://example.com/2023/12/31/useEffect/</id>
    <published>2023-12-31T08:12:37.000Z</published>
    <updated>2024-01-08T16:38:15.375Z</updated>
    
    <content type="html"><![CDATA[<p>useEffect 這一個 Hook 可以讓開發者可以處理 function component 的 side effect．</p><p>但這句話對我來說可能我很難一眼看出他到底在說什麼．所以到底什麼是 side effect，這可能得先說什麼是「純粹函式」，至於什麼是純粹函式，滿足以下兩個條件就算是符合純粹函式： 1.輸入相同的值，函式總是會給予一樣的結果，過程不會受到任何外部的干擾(或不倚賴外部狀態） 2.函式執行的過程沒有對外部的狀態進行修改，換言之，該函式執行時沒有修改全域變數、修改檔案、發送網路請求等。</p><span id="more"></span><p>若沒有滿足上述兩個條件，則在 function 執行的過程中則會產生 side effect ，舉理來說，包含但不限於以下操作都是會產生 side effect:</p><ol><li>在 react 中如果去修改父層的某一個狀態(修改外部狀態</li><li>對ＤＯＭ進行操作，即使是修改元件內部的ＤＯＭ也是，因為元件的渲染過程和 DOM 的更新是由 React 自動管理的，但如果在元件內部手動直接修改 DOM，也算是修改外部狀態。</li><li>向外發送網路請求（返回的狀態難以預測，可能會發生網路延遲、請求失敗等等的，沒有符合純粹函式的第一點）</li><li>console.log(…) 、alert(…)都是有 side effect，這是因為有涉及到與外部環境的交互（console.log 更動瀏覽器控制台）。</li></ol><p>說這些到底跟 useEffect 有什麼關係？</p><p>useEffect 這一個 hook 主要是提供讓這些 side effect 有一個合適的生命週期來執行．<br>先說說 useEffect 的主要使用方式，useEffect 主要是告訴 react 當前的這一個 component 需要有些事情要在 render 之後做．而在預設的情況下，元件的每一次 render 他都會觸發，但這個 hook 也提供了一些依賴陣列，可以設定什麼狀況會觸發這個 useEffect．</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;….&#125;, dependenciesArray)</span><br></pre></td></tr></table></figure><p>若 dependenciesArray 為[]，則僅有在元件 mount 時會執行 useEffect 內的函式一次<br>若 dependenciesArray 為[id, data]，則是當 id 或 data 狀態有變動時，會觸發 useEffect，換言之，元件只要每次重新渲染後 若 dependenciesArray 內的元素沒有改變，任何 useEffect 裡面的函式就不會被執行！</p><p>&lt;這裡還需要一些 code 來說明補充&gt;</p><p>componentDidMount：是指當 component 中畫面第一次渲染完後觸發的生命週期函數。相當於使用 useEffect 但依賴項為空陣列．當 component 完成載入時會觸發 componentDidMount 中的函式．</p><p>componentDidUpdate：是指當 component 中有 state 改變時要觸發的生命週期函數。相當於依賴項有發生變動時，才會觸發 componentDidUpdate 中的函式．</p><p>componentWillUnmount：等同 useEffect 的 return 效果，在 component 要 Unmount 時，才會觸發 componentWillUnmount 中的函式．</p><p>參考資料：<br>使用 Effect Hook<br><a href="https://zh-hant.legacy.reactjs.org/docs/hooks-effect.html">https://zh-hant.legacy.reactjs.org/docs/hooks-effect.html</a></p><p>Day 12: ES6 篇: Side Effects(副作用)與 Pure Functions(純粹函式)<br><a href="https://ithelp.ithome.com.tw/articles/10185780">https://ithelp.ithome.com.tw/articles/10185780</a></p><p>React.js Hook 入門 - 3. useEffect<br><a href="https://www.dropbox.com/paper/ep/redirect/external-link?url=https://hackmd.io/@chris80072/SJvii1yAD&hmac=Hdw2ZdivN+tPLa7gOGkeec7rCBHP34GLMh+xrMX5tuQ=">https://www.dropbox.com/paper/ep/redirect/external-link?url=https%3A%2F%2Fhackmd.io%2F%40chris80072%2FSJvii1yAD&amp;hmac=Hdw2ZdivN%2BtPLa7gOGkeec7rCBHP34GLMh%2BxrMX5tuQ%3D</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;useEffect 這一個 Hook 可以讓開發者可以處理 function component 的 side effect．&lt;/p&gt;
&lt;p&gt;但這句話對我來說可能我很難一眼看出他到底在說什麼．所以到底什麼是 side effect，這可能得先說什麼是「純粹函式」，至於什麼是純粹函式，滿足以下兩個條件就算是符合純粹函式： 1.輸入相同的值，函式總是會給予一樣的結果，過程不會受到任何外部的干擾(或不倚賴外部狀態） 2.函式執行的過程沒有對外部的狀態進行修改，換言之，該函式執行時沒有修改全域變數、修改檔案、發送網路請求等。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
